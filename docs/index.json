{
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentation",
    "keywords": "API Documentation The API documentation is automatically generated from source-code-level comments. Often, more information can be found by looking into the source code itself."
  },
  "articles/fonts/customrendering.html": {
    "href": "articles/fonts/customrendering.html",
    "title": "Custom Rendering",
    "keywords": "Custom Rendering Warning Fonts is still considered BETA quality and we still reserve the rights to change the API shapes. We are yet to priorities performance in our font loading and layout APIs. Note ImageSharp.Drawing already implements the glyph rendering for you unless you are rendering on other platforms we would recommend using the version build into that library.. this is a more advanced topic. Implementing a glyph renderer The abstraction used by Fonts to allow implementing glyph rendering is the IGlyphRenderer and its brother IColoredGlypheRenderer (for colored emoji support). // `IColoredGlyphRenderer` implements `IGlyphRenderer` so if you don't want colored font support just implement `IGlyphRenderer`. public class CustomGlyphRenderer : IColoredGlyphRenderer { /// <summary> /// Called before any glyphs have been rendered. /// </summary> /// <param name=\"bounds\">The bounds the text will be rendered at and at whats size.</param> void IGlyphRenderer.BeginText(FontRectangle bounds) { // called before any thing else to provide access to the total required size to redner the text } /// <summary> /// Begins the glyph. /// </summary> /// <param name=\"bounds\">The bounds the glyph will be rendered at and at what size.</param> /// <param name=\"paramaters\">The set of paramaters that uniquely represents a version of a glyph in at particular font size, font family, font style and DPI.</param> /// <returns>Returns true if the glyph should be rendered othersie it returns false.</returns> bool IGlyphRenderer.BeginGlyph(FontRectangle bounds, GlyphRendererParameters paramaters) { // called before each glyph/glyph layer is rendered. // The paramaters can be used to detect the exact details // of the glyph so that duplicate glyphs could optionally // be cached to reduce processing. // You can return false to skip all the figures within the glyph (if you return false EndGlyph will still be called) } /// <summary> /// Sets the color to use for the current glyph. /// </summary> /// <param name=\"color\">The color to override the renders brush with.</param> void IColorGlyphRenderer.SetColor(GlyphColor color) { // from the IColorGlyphRenderer version, onlt called if the current glyph should override the forgound color of current glyph/layer } /// <summary> /// Begins the figure. /// </summary> void IGlyphRenderer.BeginFigure() { // called at the start of the figure within the single glyph/layer // glyphs are rendered as a serise of arcs, lines and movements // which together describe a complex shape. } /// <summary> /// Sets a new start point to draw lines from /// </summary> /// <param name=\"point\">The point.</param> void IGlyphRenderer.MoveTo(Vector2 point) { // move current point to location marked by point without describing a line; } /// <summary> /// Draw a quadratic bezier curve connecting the previous point to <paramref name=\"point\"/>. /// </summary> /// <param name=\"secondControlPoint\">The second control point.</param> /// <param name=\"point\">The point.</param> void IGlyphRenderer.QuadraticBezierTo(Vector2 secondControlPoint, Vector2 point) { // describes Quadratic Bezier curve from the 'current point' using the // 'second control point' and final 'point' leaving the 'current point' // at 'point' } /// <summary> /// Draw a Cubics bezier curve connecting the previous point to <paramref name=\"point\"/>. /// </summary> /// <param name=\"secondControlPoint\">The second control point.</param> /// <param name=\"thirdControlPoint\">The third control point.</param> /// <param name=\"point\">The point.</param> void IGlyphRenderer.CubicBezierTo(Vector2 secondControlPoint, Vector2 thirdControlPoint, Vector2 point) { // describes Cubic Bezier curve from the 'current point' using the // 'second control point', 'third control point' and final 'point' // leaving the 'current point' at 'point' } /// <summary> /// Draw a straight line connecting the previous point to <paramref name=\"point\"/>. /// </summary> /// <param name=\"point\">The point.</param> void IGlyphRenderer.LineTo(Vector2 point) { // describes straight line from the 'current point' to the final 'point' // leaving the 'current point' at 'point' } /// <summary> /// Ends the figure. /// </summary> void IGlyphRenderer.EndFigure() { // Called after the figure has completed denoting a straight line should // be drawn from the current point to the first point } /// <summary> /// Ends the glyph. /// </summary> void IGlyphRenderer.EndGlyph() { // says the all figures have completed for the current glyph/layer. // NOTE this will be called even if BeginGlyph return false. } /// <summary> /// Called once all glyphs have completed rendering /// </summary> void IGlyphRenderer.EndText() { //once all glyphs/layers have been drawn this is called. } }"
  },
  "articles/fonts/gettingstarted.html": {
    "href": "articles/fonts/gettingstarted.html",
    "title": "Getting Started",
    "keywords": "Getting Started Warning Fonts is still considered BETA quality and we still reserve the rights to change the API shapes. We are yet to priorities performance in our font loading and layout APIs. Note The official guide assumes intermediate level knowledge of C# and .NET. If you are totally new to .NET development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back. Prior experience with other languages and frameworks helps, but is not required. Fonts Fonts provides the core to your text layout and loading subsystems. SixLabors.Fonts.FontCollection is the root type you will configure and load up with all the TrueType/OpenType/Woff fonts. (font loading is deemed expensive and should be done once and shared across multiple rasterizations) SixLabors.Fonts.Font is our currying type for passing information about your chosen font face. Loading Fonts Fonts provides several options for loading fonts, you can load then from a streams or files, we also support loading collections out of *.TTC files and well as single variants out if individual *.TTF files. We also support loading *.woff files. Minimal Example using SixLabors.Fonts; FontCollection collection = new FontCollection(); FontFamily family = collection.Install(\"path/to/font.ttf\"); Font font = family.Create(12, FontStyle.Italic); // \"font\" can now be used in calls to DrawText from our ImageSharp.Drawing library. Expanded Example using SixLabors.Fonts; FontCollection collection = new FontCollection(); collection.Install(\"path/to/font.ttf\"); collection.Install(\"path/to/font2.ttf\"); collection.Install(\"path/to/emojiFont.ttf\"); collection.InstallCollection(\"path/to/font.ttc\"); if(collection.TryFind(\"Font Name\", out FontFamily family)) if(collection.TryFind(\"Emoji Font Name\", out FontFamily emojiFamily)) { // family will not be null here Font font = family.Create(12, FontStyle.Italic); RendererOptions options = new RendererOptions(font, dpi: 72) { ApplyKerning = true, FallbackFontFamilies = new [] { emojiFamily // will be used if a particular code point doesn't exist in the font passed into the constructor. (e.g. emoji) } }; FontRectangle rect = TextMeasurer.Measure(\"Text to measure\", options); }"
  },
  "articles/fonts/index.html": {
    "href": "articles/fonts/index.html",
    "title": "Introduction",
    "keywords": "Introduction Warning Fonts is still considered BETA quality and we still reserve the rights to change the API shapes. WE are yet to priorities performance in our drawing APIs. What is Fonts? Fonts is a font loading and layout library built primarily to provide text drawing support to ImageSharp.Drawing. Built against .NET Standard 1.3 , Fonts can be used in device, cloud, and embedded/IoT scenarios. License Fonts is licensed under under the terms of GNU Affero General Public License, version 3 . Commercial licensing options are available in addition to this license, see https://sixlabors.com/pricing for details. Installation ImageSharp.Drawing is installed via Nuget with nightly builds available on MyGet . Package Manager .NET CLI PackageReference Paket CLI PM > Install-Package SixLabors.Fonts -Version VERSION_NUMBER dotnet add package SixLabors.Fonts --version VERSION_NUMBER <PackageReference Include=\"SixLabors.Fonts\" Version=\"VERSION_NUMBER\" /> paket add SixLabors.Fonts --version VERSION_NUMBER Warning Prerelease versions installed via the Visual Studio Nuget Package Manager require the \"include prerelease\" checkbox to be checked."
  },
  "articles/imagesharp.drawing/gettingstarted.html": {
    "href": "articles/imagesharp.drawing/gettingstarted.html",
    "title": "Getting Started",
    "keywords": "Getting Started Warning ImageSharp.Drawing is still considered BETA quality and we still reserve the rights to change the API shapes. WE are yet to priorities performance in our drawing APIs. Note The official guide assumes intermediate level knowledge of C# and .NET. If you are totally new to .NET development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back. Prior experience with other languages and frameworks helps, but is not required. ImageSharp.Drawing - Paths and Polygons ImageSharp.Drawing provides several classes for build and manipulating various shapes and paths. @\"SixLabors.ImageSharp.Drawing.IPath\" Root interface defining a path/polygon and the type that the rasterizer uses to generate pixel output. This SixLabors.ImageSharp.Drawing namespace contains a variety of available polygons to speed up your drawing process. In addition to the vector manipulation APIs we also have the rasterization APIs that can convert your @\"SixLabors.ImageSharp.Drawing.IPath\"s to pixels. Drawing Polygons ImageSharp provides several options for drawing polygons weather you want to draw outlines or fill the shapes. Minimal Example using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using SixLabors.ImageSharp.Drawing.Processing; Image image = ...; // create any way you like. IPath yourPolygon = new Star(x: 100.0f, y: 100.0f, prongs: 5, innerRadii: 20.0f, outerRadii:30.0f) image.Mutate( x=> x.Fill(Color.Red, yourPolygon)); // fill the star with red Expanded Example using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using SixLabors.ImageSharp.Drawing.Processing; using SixLabors.ImageSharp.PixelFormats; Image image = ...; // create any way you like. // The options are optional ShapeGraphicsOptions options = new ShapeGraphicsOptions() { ColorBlendingMode = PixelColorBlendingMode.Multiply }; IBrush brush = Brushes.Horizontal(Color.Red, Color.Blue); IPen pen = Pens.DashDot(Color.Green, 5); IPath yourPolygon = new Star(x: 100.0f, y: 100.0f, prongs: 5, innerRadii: 20.0f, outerRadii:30.0f) // draws a star with Horizontal red and blue hatching with a dash dot pattern outline. image.Mutate( x=> x.Fill(options, brush, yourPolygon) .Draw(option, pen, yourPolygon)); API Cornerstones for Polygon Rasterization Our Fill APIs always work off a Brush (some helpers create the brush for you) and will take your provided set of paths and polygons filling in all the pixels inside the vector with the color the brush provides. Our Draw APIs always work off the Pen where we processes your vector to create an outline with a certain pattern and fill in the outline with an internal brush inside the pen. Drawing Text ImageSharp.Drawing provides several options for drawing text all overloads of a single DrawText API. Our text drawing infrastructure is build on top of our Fonts library. (See SixLabors.Fonts for details on handling fonts.) Minimal Example using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using SixLabors.ImageSharp.Drawing.Processing; Image image = ...; // create any way you like. Font font = ...; // see our Fonts library for best practices on retriving one of these. string yourText = \"this is some sample text\"; image.Mutate( x=> x.DrawText(yourText, font, Color.Black, new PointF(10, 10))); Expanded Example using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using SixLabors.ImageSharp.Drawing.Processing; using SixLabors.ImageSharp.PixelFormats; Image image = ...; // create any way you like. Font font = ...; // see our Fonts library for best practices on retriving one of these. // The options are optional TextGraphicsOptions options = new TextGraphicsOptions() { ApplyKerning = true, TabWidth = 8, // a tab renders as 8 spaces wide WrapTextWidth = 100, // greater than zero so we will word wrap at 100 pixels wide HorizontalAlignment = HorizontalAlignment.Right // right align }; IBrush brush = Brushes.Horizontal(Color.Red, Color.Blue); IPen pen = Pens.DashDot(Color.Green, 5); string text = \"sample text\"; // draws a star with Horizontal red and blue hatching with a dash dot pattern outline. image.Mutate( x=> x.DrawText(options, text, font, brush, pen, new PointF(100, 100));"
  },
  "articles/imagesharp.drawing/index.html": {
    "href": "articles/imagesharp.drawing/index.html",
    "title": "Introduction",
    "keywords": "Introduction Warning ImageSharp.Drawing is still considered BETA quality and we still reserve the rights to change the API shapes. WE are yet to priorities performance in our drawing APIs. What is ImageSharp.Drawing? ImageSharp.Drawing is a library build on top on ImageSharp to providing 2D Drawing extensions on top of ImageSharp. ImageSharp.Drawing is designed from the ground up to be flexible and extensible. The library provides API endpoints for common vector and text processing operations adds the building blocks for building custom image. Built against .NET Standard 1.3 , ImageSharp.Drawing can be used in device, cloud, and embedded/IoT scenarios. License ImageSharp.Drawing is licensed under under the terms of GNU Affero General Public License, version 3 . Commercial licensing options are available in addition to this license, see https://sixlabors.com/pricing for details. Installation ImageSharp.Drawing is installed via Nuget with nightly builds available on MyGet . Package Manager .NET CLI PackageReference Paket CLI PM > Install-Package SixLabors.ImageSharp.Drawing -Version VERSION_NUMBER dotnet add package SixLabors.ImageSharp.Drawing --version VERSION_NUMBER <PackageReference Include=\"SixLabors.ImageSharp.Drawing\" Version=\"VERSION_NUMBER\" /> paket add SixLabors.ImageSharp.Drawing --version VERSION_NUMBER Warning Prerelease versions installed via the Visual Studio Nuget Package Manager require the \"include prerelease\" checkbox to be checked."
  },
  "articles/imagesharp/configuration.html": {
    "href": "articles/imagesharp/configuration.html",
    "title": "",
    "keywords": "TODO"
  },
  "articles/imagesharp/gettingstarted.html": {
    "href": "articles/imagesharp/gettingstarted.html",
    "title": "Getting Started",
    "keywords": "Getting Started Note The official guide assumes intermediate level knowledge of C# and .NET. If you are totally new to .NET development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back. Prior experience with other languages and frameworks helps, but is not required. ImageSharp Images ImageSharp provides several classes for storing pixel data: @\"SixLabors.ImageSharp.Image\" A pixel format agnostic image container used for general processing operations. @\"SixLabors.ImageSharp.Image`1\" A generic image container that allows per-pixel access. In addition there are classes available that represent individual image frames: @\"SixLabors.ImageSharp.ImageFrame\" A pixel format agnostic image frame container. @\"SixLabors.ImageSharp.ImageFrame`1\" A generic image frame container that allows per-pixel access. @\"SixLabors.ImageSharp.Processing.Processors.Quantization.IndexedImageFrame`1\" A generic image frame used for indexed image pixel data where each pixel buffer value represents an index in a color palette. For more information on pixel formats please see the following documentation . Loading and Saving Images ImageSharp provides several options for loading and saving images to cover different scenarios. The library automatically detects the source image format upon load and it is possible to dictate which image format to save an image pixel data to. using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; // Open the file automatically detecting the file type to decode it. // Our image is now in an uncompressed, file format agnostic, structure in-memory as // a series of pixels. using (Image image = Image.Load(\"foo.jpg\")) { // Resize the image in place and return it for chaining. // 'x' signifies the current image processing context. image.Mutate(x => x.Resize(image.Width / 2, image.Height / 2)); // The library automatically picks an encoder based on the file extension then // encodes and write the data to disk. // You can optionally set the encoder to choose. image.Save(\"bar.jpg\"); } // Dispose - releasing memory into a memory pool ready for the next image you wish to process. In this very basic example you are actually utilizing several core ImageSharp features: Image Formats by loading and saving an image. Image Processors by calling Mutate() and Resize() Initializing New Images using SixLabors.ImageSharp; using SixLabors.ImageSharp.PixelFormats; using SixLabors.ImageSharp.Processing; int width = 640; int height = 480; // Creates a new image with empty pixel data. using(var image = new Image<Rgba32>(width, height)) { // Do your drawing in here... } // Dispose - releasing memory into a memory pool ready for the next image you wish to process. In this example you are utilizing the following core ImageSharp feature: Pixel Formats by using Rgba32 API Cornerstones The easiest way to work with ImageSharp is to utilize our extension methods: @\"SixLabors.ImageSharp\" for basic operations and primitives. @\"SixLabors.ImageSharp.Processing\" for Mutate() and Clone() . All the processing extensions (eg. Resize(...) ) live within this namespace. Performance Achieving near-to-native performance is a major goal for the SixLabors team, and thanks to the improvements brought by the RyuJIT runtime, it's no longer mission impossible. We have made great progress and are constantly working on improvements. At the moment it's pretty hard to define fair benchmarks comparing GDI+ (aka. System.Drawing on Windows) and ImageSharp, because of the differences between the algorithms being used. Generally speaking, we are more feature rich, producing better quality. We hope we can match the corresponding algorithm parameters, and present some very specific benchmark results soon. If you are experiencing a significant performance gap between System.Drawing and ImageSharp for basic use-cases, there is a high chance that essential SIMD optimizations are not utilized. A few troubleshooting steps to try: Check the value of Vector.IsHardwareAccelerated . If the output is false, it means there is no SIMD support in your runtime! Make sure your code runs on 64bit! Older .NET Framework versions are using the legacy runtime on 32 bits, having no built-in SIMD support."
  },
  "articles/imagesharp/imageformats.html": {
    "href": "articles/imagesharp/imageformats.html",
    "title": "Image Formats",
    "keywords": "Image Formats Out of the box ImageSharp supports the following image formats: Jpeg Png Bmp Gif Tga ImageSharp's API however, is designed to support extension by the registration of additional IImageFormat implementations. Loading and Saving Specific Image Formats Image<TPixel> represents raw pixel data, stored in a contiguous memory block. It does not \"remember\" the original image format. ImageSharp identifies image formats (Jpeg, Png, Gif etc.) by IImageFormat instances. There are several overloads of Image.Load capable of returning the format as an out parameter. It's possible to pass that value to image.Save after performing the operation: IImageFormat format; using (var image = Image.Load(inputStream, out format)) { image.Mutate(c => c.Resize(30, 30)); image.Save(outputStream, format); } Note ImageSharp provides common extension methods to save an image into a stream using a specific format. image.SaveAsJpeg() (shortcut for image.Save(new JpegEncoder()) ) image.SaveAsPng() (shortcut for image.Save(new PngEncoder()) ) image.SaveAsGif() (shortcut for image.Save(new GifEncoder()) ) image.SaveAsBmp() (shortcut for image.Save(new BmpEncoder()) ) image.SaveAsTga() (shortcut for image.Save(new TgaEncoder()) ) A Deeper Overview of ImageSharp Format Management Real life image streams are usually stored / transferred in standardized formats like Jpeg, Png, Bmp, Gif etc. An image format is represented by an IImageFormat implementation. IImageDecoder is responsible for decoding streams (and files) in into Image<TPixel> . ImageSharp can auto-detect the image formats of streams/files based on their headers, selecting the correct IImageFormat (and thus IImageDecoder ). This logic is implemented by IImageFormatDetector 's. IImageEncoder is responsible for writing Image<TPixel> into a stream using a given format. Decoders/encoders and IImageFormatDetector 's are mapped to image formats in ImageFormatsManager . It's possible to register new formats, or drop existing ones. See Configuration for more details. Metadata-only Decoding Sometimes it's worth to efficiently decode image metadata ignoring the memory and CPU heavy pixel information inside the stream. ImageSharp allows this by using one of the several Image.Identify overloads: using (IImageInfo imageInfo = Image.Identify(inputStream)) { Console.WriteLine($\"{imageInfo.Width}x{imageInfo.Height} | BPP: {imageInfo.PixelType.BitsPerPixel}\"); } See IImageInfo for more details about the identification result. Note that Image<TPixel> also implements IImageInfo . Working with Encoders Image formats are usually defined by complex standards allowing multiple representations for the same image. ImageSharp allows parameterizing the encoding process: IImageEncoder implementations are stateless, lightweight parametric objects. This means that if you want to encode a Png in a specific way (eg. changing the compression level), you need to new-up a custom PngEncoder instance. Choosing the right encoder parameters allows to balance between conflicting tradeoffs: Image file size Encoder speed Image quality Each encoder offers options specific to the image format it represents."
  },
  "articles/imagesharp/index.html": {
    "href": "articles/imagesharp/index.html",
    "title": "Introduction",
    "keywords": "Introduction What is ImageSharp? ImageSharp is a new, fully featured, fully managed, cross-platform, 2D graphics library. Designed to democratize image processing, ImageSharp brings you an incredibly powerful yet beautifully simple API. ImageSharp is designed from the ground up to be flexible and extensible. The library provides API endpoints for common image processing operations and the building blocks to allow for the development of addtional operations. Built against .NET Standard 1.3 , ImageSharp can be used in device, cloud, and embedded/IoT scenarios. License Imagesharp is licensed under under the terms of GNU Affero General Public License, version 3 . Commercial licensing options are available in addition to this license, see https://sixlabors.com/pricing for details. Installation ImageSharp is installed via Nuget with nightly builds available on MyGet . Package Manager .NET CLI PackageReference Paket CLI PM > Install-Package SixLabors.ImageSharp -Version VERSION_NUMBER dotnet add package SixLabors.ImageSharp --version VERSION_NUMBER <PackageReference Include=\"SixLabors.ImageSharp\" Version=\"VERSION_NUMBER\" /> paket add SixLabors.ImageSharp --version VERSION_NUMBER Warning Prerelease versions installed via the Visual Studio Nuget Package Manager require the \"include prerelease\" checkbox to be checked."
  },
  "articles/imagesharp/memorymanagement.html": {
    "href": "articles/imagesharp/memorymanagement.html",
    "title": "Memory Management",
    "keywords": "Memory Management ImageSharp seems to retain ~300-400 MB of managed memory even after disposing all my images. Is this a memory leak? By default, ImageSharp uses ArrayPool's for performance reasons, however this behavior is fully configurable. All large buffers are managed by the @\"SixLabors.ImageSharp.Memory.MemoryAllocator\" implementation associated to @\"SixLabors.ImageSharp.Configuration\"'s @\"SixLabors.ImageSharp.Configuration.MemoryAllocator\" property. We are using @\"SixLabors.ImageSharp.Memory.ArrayPoolMemoryAllocator\" by default, in order to utilize the benefits of array pooling: Less pressure on GC, because buffers are being reused most of the time Reduced LOH fragmentation When working with unclean buffers is acceptable, we can spare on GC-s array cleaning behavior too Summary : pooling helps us to reduce CPU work and increase throughput for the cost of a larger memory footprint. Working in memory constrained environments Sometimes having ~300 MB memory footprint is not an option. Let's mention a few cases: When horizontal scaling is achieved by having multiple memory constrained containers in a cloud environment. Mobile applications. Before scaling down pooling behavior because of unwanted OutOfMemoryException -s in a cloud or desktop environment: Keep in mind that image processing is a memory intensive application! This may affect your scaling strategy. We don't recommend using containers with 1 GB or smaller memory limit! Make sure that you are running your service in a 64 bit process ! There are several pre-defined factory methods to create an @\"SixLabors.ImageSharp.Memory.ArrayPoolMemoryAllocator\" instance for memory constrained environments. For example @\"SixLabors.ImageSharp.Memory.ArrayPoolMemoryAllocator.CreateWithModeratePooling\" might be suitable in most constrained situations: Configuration.Default.MemoryAllocator = ArrayPoolMemoryAllocator.CreateWithModeratePooling(); Of course, you may also configure a MemoryAllocator on your own @\"SixLabors.ImageSharp.Configuration\" instance. You can find benchmark results in the original PR which may help to select you a configuration, but they are bit outdated, because our throughput got better since then! Releasing pools programatically If your application uses ImageSharp sporadically (eg. generating some images on startup, or on other non-frequent use-cases), you may want to release the retained pools using @\"SixLabors.ImageSharp.Memory.MemoryAllocator.ReleaseRetainedResources\": Configuration.Default.MemoryAllocator.ReleaseRetainedResources(); Using multiple MemoryAllocator instances in the same process You need to create and maintain your own @\"SixLabors.ImageSharp.Configuration\" instance, setting a specific MemoryAllocator on it. It's possible to pass custom Configuration instances to methods accross our whole API."
  },
  "articles/imagesharp/pixelformats.html": {
    "href": "articles/imagesharp/pixelformats.html",
    "title": "Pixel Formats",
    "keywords": "Pixel Formats Why is @\"SixLabors.ImageSharp.Image`1\" a generic class? We support multiple pixel formats just like System.Drawing does. However, unlike their closed PixelFormat enumeration, our solution is extensible. A pixel is basically a small value object (struct), describing the color at a given point according to a pixel model we call Pixel Format. Image<TPixel> represents a pixel graphic bitmap stored as a generic, contiguous memory block of pixels, of size image.Width * image.Height . In the case of multi-frame images (usually decoded from gifs) multiple bitmaps are stored in image.Frames as ImageFrame<TPixel> instances. Choosing Pixel Formats Have a look at the various pixel formats available under @\"SixLabors.ImageSharp.PixelFormats#structs\" After picking the pixel format of your choice, use it as a generic argument for , eg. by instantiating Image<Bgr24> . Defining Custom Pixel Formats Yes, you just need to define a struct implementing and use it as a generic argument for . However, at the moment you won't be able to provide SIMD-optimized batched pixel-conversion primitives. We need to open up the API to allow that. I have a monochrome image and I want to store it in a compact way. Can I store a pixel on a single bit? No. Our architecture does not allow sub-byte pixel formats at the moment. This feature is incredibly complex to implement, and you are going to pay the price of the low memory footprint in processing speed / CPU load. Can I decode into pixel formats like CMYK or CIELAB ? Unfortunately it's not possible and is unlikely to be in the future. Many image processing operations expect the pixels to be laid out in-memory in RGBA format. To manipulate images in exotic colorspaces we would have to translate each pixel to-and-from the colorspace multiple times, which would result in unusable performance and a loss of color information."
  },
  "articles/imagesharp/processing.html": {
    "href": "articles/imagesharp/processing.html",
    "title": "Processing Image Operations",
    "keywords": "Processing Image Operations The ImageSharp processing API is imperative. This means that the order in which you supply the individual processing operations is the order in which they are are compiled and applied. This allows the API to be very flexible, allowing you to combine processes in any order. Processing operations are implemented using one of two available method calls. Mutate and Clone The difference being that the former applies the given processing operations to the current image whereas the latter applies the operations to a deep copy of the original image. For example: Mutate using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using (Image image = Image.Load(inStream)) { // Resize the given image in place and return it for chaining. // 'x' signifies the current image processing context. image.Mutate(x => x.Resize(image.Width / 2, image.Height / 2)); image.Save(outStream); } // Dispose - releasing memory into a memory pool ready for the next image you wish to process. Clone using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using (Image image = Image.Load(inStream)) { // Create a deep copy of the given image, resize it, and return it for chaining. using (Image copy = image.Clone(x => x.Resize(image.Width / 2, image.Height / 2))) { copy.Save(outStream); } } // Dispose - releasing memory into a memory pool ready for the next image you wish to process. Common Examples Examples of common operations can be found in the following documentation pages. Resizing images using different options."
  },
  "articles/imagesharp/resize.html": {
    "href": "articles/imagesharp/resize.html",
    "title": "Resizing Images",
    "keywords": "Resizing Images Resizing an image is probably the most common processing operation that applications use. ImageSharp offers an incredibly flexible collection of resize options that allow developers to choose sizing algorithms, sampling algorithms, and gamma handling as well as other options. The Basics Resizing an image involves the process of creating and iterating through the pixels of a target image and sampling areas of a source image to choose what color to implement for each pixel. The sampling algorithm chosen affects the target color and can dramatically alter the result. Different samplers are usually chosen based upon the use case - For example NearestNeigbor is often used for fast, low quality thumbnail generation, Lanczos3 for high quality thumbnails due to it's sharpening effect, and Spline for high quality enlargment due to it's smoothing effect. With ImageSharp we default to Bicubic as it is a very robust algorithm offering good quality output when both reducing and enlarging images but you can easily set the algorithm when processing. A full list of supported sampling algorithms can be found here : Resize the given image using the default Bicubic sampler. using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using (Image image = Image.Load(inStream)) { int width = image.Width / 2; int height = image.Height / 2; image.Mutate(x => x.Resize(width, height)); image.Save(outStream); } Resize the given image using the Lanczos3 sampler: using SixLabors.ImageSharp; using SixLabors.ImageSharp.Processing; using (Image image = Image.Load(inStream)) { int width = image.Width / 2; int height = image.Height / 2; image.Mutate(x => x.Resize(width, height, KnownResamplers.Lanczos3)); image.Save(outStream); } Note If you pass 0 as any of the values for width and height dimensions then ImageSharp will automatically determine the correct opposite dimensions size to preserve the original aspect ratio. Advanced Resizing In addition to basic resizing operations ImageSharp also offers more advanced features. TODO: Add advanced description and code examples."
  },
  "articles/imagesharp/workingwithpixelbuffers.html": {
    "href": "articles/imagesharp/workingwithpixelbuffers.html",
    "title": "Working with pixel buffers",
    "keywords": "Working with pixel buffers Setting individual pixels using indexers A very basic and readable way for manipulating individual pixels is to use the indexer either on Image<T> or ImageFrame<T> : using (Image<Rgba32> image = new Image<Rgba32>(400, 400)) { image[200, 200] = Rgba32.White; // also works on ImageFrame<T> } The idexer is much faster than the .GetPixel(x, y) and .SetPixel(x,y) methods of System.Drawing but, it's still quite slow. Efficient pixel manipulation If you want to achieve killer speed in your own low-level pixel manipulation routines, you need to utilize extension methods within the class. These methods are using the brand-new Span<T> -based memory manipulation primitives from System.Memory , providing a fast, yet safe low-level solution to manipulate pixel data. This is how you can implement efficient row-by-row pixel manipulation: using SixLabors.ImageSharp.Advanced; // ... using (Image<Rgba32> image = new Image<Rgba32>(400, 400)) { for (int y = 0; y < image.Height; y++) { Span<Rgba32> pixelRowSpan = image.GetPixelRowSpan(y); for (int x = 0; x < image.Width; x++) { pixelRowSpan[x] = new Rgba32(x/255, y/255, 50, 255); } } } Span<T> limitations Please be aware that Span<T> has a very specific limitation : it is a stack-only type! Read the Is There Anything Span Can’t Do?! section in this article for more details. A short summary of the limitations: Span can only live on the execution stack. Span cannot be boxed or put on the heap. Span cannot be used as a generic type argument. Span cannot be an instance field of a type that itself is not stack-only. Span cannot be used within asynchronous methods. Non-conformant code: Span<Rgba32> span = image.GetRowSpan(y); await Task.Run(() => { // ☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠☠ // ☠☠☠ BANG! YOU HAVE CAPTURED A SPAN ON THE HEAP! ☠☠☠ for (int i = 0; i < span.Length; i++) { span[i] = /* ... */; } }); Exporting raw pixel data from an Image<T> You can use image.GetPixelSpan() to access the whole contigous pixel buffer, eg. to copy the pixel data into an array: Rgba32[] pixelArray = image.GetPixelSpan().ToArray(); Or: Rgba32[] pixelArray = /* your pixel buffer being reused */ image.GetPixelSpan().CopyTo(pixelArray); Or: byte[] rgbaBytes = MemoryMarshal.AsBytes(image.GetPixelSpan()).ToArray(); Loading raw pixel data into an Image<T> Rgba32[] rgbaData = GetMyRgbaArray(); using (var image = Image.LoadPixelData(rgbaData)) { // Work with image } byte[] rgbaBytes = GetMyRgbaBytes(); using (var image = Image.LoadPixelData<Rgba32>(rgbaBytes)) { // Work with image }"
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Introduction",
    "keywords": "Introduction This is a FAQ-style guide for our API. We tried to provide short answers for the most common questions concerning our libraries. Using Six Labors libraries Stable and beta releases are available on NuGet For beta versions, make sure that the Include Prerelease switch is enabled! Console: Install-Package SixLabors.ImageSharp -IncludePrerelease Visual Studio: Looking for our latest features or bugfixes? Download nightly builds from MyGet: SixLabors.ImageSharp SixLabors.ImageSharp.Drawing Don't forget to add our MyGet package source: https://www.myget.org/F/sixlabors/api/v3/index.json Contributing Discuss your ideas Contribution Guide Can't find what you're looking for? Try exploring our API documentation Check out our Samples Repository If you still don't find what you're looking for, feel free to ping us on our Gitter channel . Please do not open GitHub issues for questions, we'd like to keep it for issue/bug tracking only!"
  },
  "index.html": {
    "href": "index.html",
    "title": "Six Labors Documentation.",
    "keywords": "Six Labors Documentation. We aim to provide modern, cross-platform, incredibly powerful yet beautifully simple graphics libraries. Built against .NET Standard, our libraries can be used in device, cloud, and embedded/IoT scenarios. You can find tutorials, examples and API details covering all Six Labors projects. API documentation Detailed documentation for the entire API available across our projects. Conceptual Documentation Our graphics libraries are split into different projects. They cover different concerns separately, but there is strong cohesion in order to provide the best developer experience. You can find documentation for each project in the links below. ImageSharp Fully featured 2D graphics API Learn More > ImageSharp.Drawing 2D polygon Manipulation and Drawing. Learn More > ImageSharp.Web ASP.NET Core Image Manipulation Middleware. Learn More > Fonts Font Loading and Drawing API. Learn More > Examples Repository We have implemented short self-contained sample projects for a few specific use cases, including: Avatar with rounded corners Crops rounded corners of a source image leaving a nice rounded avatar. Draw watermark on image Draw water mark over an image automaticaly scaling the font size to fill the avalible space. Change default encoder options Provides an example on how you go about switching out the registered encoder for a file format and changing its default options in the process. Draw text along a path Draw some text following the contours of a path."
  }
}